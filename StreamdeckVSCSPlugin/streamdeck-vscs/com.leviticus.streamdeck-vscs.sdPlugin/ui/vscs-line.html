<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>VSCS Line</title>
	<style>
		body {
			font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
			margin: 12px;
		}
		.subtle {
			color: #888;
			font-size: 12px;
			margin-top: 4px;
		}
		#status {
			color: #888;
			font-size: 12px;
			margin-top: 6px;
		}
		#hint {
			color: #bbb;
			font-size: 12px;
			margin-top: 6px;
			line-height: 1.4;
		}
		.hidden { display: none; }
	</style>
</head>
<body>
	<sdpi-item label="Mode">
		<select id="modeSelect" class="sdpi-item-value">
			<option value="auto">Auto-detect (stable ID)</option>
			<option value="manual">Manual pick</option>
		</select>
	</sdpi-item>
	<sdpi-item label="Auto ID" id="autoRow">
		<select id="slotSelect" class="sdpi-item-value">
			<option value="">Select ID...</option>
		</select>
	</sdpi-item>
	<sdpi-item label="Manual Line" id="manualRow">
		<select id="lineSelect" class="sdpi-item-value">
			<option value="">Select line...</option>
		</select>
	</sdpi-item>
	<div id="hint">Auto-detect uses an ID so the same button keeps its place as VSCS lines appear/disappear. Give each auto line button a unique ID. Switch to Manual to lock this button to a specific detected line.</div>
	<div id="status"></div>

	<script>
	(() => {
		const AUTO_IDS = Array.from({ length: 60 }, (_, i) => (i + 1).toString());
		const ROLE_TOKENS = new Set(["CTR", "CENTER", "CENTRE", "APP", "APCH", "APPROACH", "DEP", "DEPARTURE", "TWR", "TOWER", "ACC", "AREA"]);
		const GROUND_TOKENS = new Set(["GND", "GROUND", "GRND"]);
		const LOCATION_ALIASES = {
			MUN: { code: "MUN", label: "Mungo" },
			SY: { label: "Sydney" }
		};
		let uuid;
		let websocket;
		let actionInfo;
		let currentSettings = {};
		let options = [];
		let fallbackTimer;
		let lineSelect;
		let slotSelect;
		let modeSelect;
		let statusEl;

		function ensureElements() {
			lineSelect = lineSelect || document.getElementById("lineSelect");
			slotSelect = slotSelect || document.getElementById("slotSelect");
			modeSelect = modeSelect || document.getElementById("modeSelect");
			statusEl = statusEl || document.getElementById("status");
		}

		function init() {
			ensureElements();
			renderSlotOptions();
			lineSelect.addEventListener("change", handleLineChange);
			slotSelect.addEventListener("change", handleSlotChange);
			modeSelect.addEventListener("change", handleModeChange);
			setStatus("Waiting for Stream Deck...");
		}

		window.connectElgatoStreamDeckSocket = function(port, inUuid, registerEvent, info, inActionInfo) {
			ensureElements();
			uuid = inUuid;
			actionInfo = JSON.parse(inActionInfo || "{}");
			currentSettings = actionInfo?.payload?.settings || {};
			websocket = new WebSocket(`ws://127.0.0.1:${port}`);

			websocket.onopen = () => {
				websocket.send(JSON.stringify({ event: registerEvent, uuid }));
				websocket.send(JSON.stringify({ event: "getSettings", context: uuid }));
				requestOptions();
			};

			websocket.onmessage = handleMessage;
			websocket.onerror = () => setStatus("Connection error. Check Stream Deck.");

			renderSlotOptions();
			applySettings(currentSettings);
		};

		document.addEventListener("DOMContentLoaded", init);

		function handleMessage(ev) {
			let msg;
			try {
				msg = JSON.parse(ev.data);
			} catch {
				return;
			}

			if (msg.event === "sendToPropertyInspector" && msg.payload?.type === "options") {
				useOptions(msg.payload.options || []);
			}

			if (msg.event === "didReceiveSettings") {
				applySettings(msg.payload?.settings);
			}
		}

		function handleLineChange(ev) {
			if (resolveMode(currentSettings) !== "manual") return;
			const targetId = ev.target.value || null;
			mergeAndSaveSettings({ targetId });
			sendToPlugin({ type: "setTarget", targetId });
		}

		function handleSlotChange(ev) {
			if (resolveMode(currentSettings) !== "auto") return;
			const autoAssignId = ev.target.value || null;
			const patch = autoAssignId ? { autoAssignId, targetId: null } : { autoAssignId };
			if (autoAssignId && lineSelect) {
				lineSelect.value = "";
			}
			mergeAndSaveSettings(patch);
			sendToPlugin({ type: "setAutoAssign", autoAssignId });
			setStatus(autoAssignId ? `Auto-detect armed on ID ${autoAssignId}.` : "");
		}

		function handleModeChange(ev) {
			const mode = ev.target.value === "manual" ? "manual" : "auto";
			const patch =
				mode === "auto"
					? { mode, targetId: null }
					: { mode, autoAssignId: null };
			mergeAndSaveSettings(patch);
			if (mode === "auto" && slotSelect && !slotSelect.value) {
				slotSelect.value = AUTO_IDS[0];
				patch.autoAssignId = AUTO_IDS[0];
				mergeAndSaveSettings(patch);
			}
			sendToPlugin({ type: "setMode", mode });
			updateVisibility();
		}

		function requestOptions() {
			setStatus("Loading VSCS lines...");
			sendToPlugin({ type: "requestOptions" });
			if (fallbackTimer) clearTimeout(fallbackTimer);
			fallbackTimer = setTimeout(loadFallbackOptions, 750);
		}

		async function loadFallbackOptions() {
			try {
				const res = await fetch("http://127.0.0.1:18084/state");
				const state = await res.json();
				useOptions(buildOptions(state?.lines || []));
			} catch (err) {
				setStatus("Unable to load VSCS state.");
				console.error(err);
			}
		}

		function useOptions(next) {
			options = next || [];
			renderOptions();
			setStatus(options.length ? "" : "No lines reported by VSCS.");
		}

		function renderOptions() {
			const current = lineSelect.value || "";
			lineSelect.innerHTML = "";

			const placeholder = document.createElement("option");
			placeholder.value = "";
			placeholder.textContent = "Select line...";
			lineSelect.appendChild(placeholder);

			const seen = new Set();
			options.forEach((opt) => {
				if (!opt || seen.has(opt.id)) return;
				seen.add(opt.id);
				const el = document.createElement("option");
				el.value = opt.id;
				el.textContent = opt.detail ? `${opt.label} - ${opt.detail}` : opt.label;
				lineSelect.appendChild(el);
			});

			const desired = (currentSettings?.targetId ?? current ?? "") || "";
			lineSelect.value = desired;
		}

		function applySettings(settings) {
			currentSettings = settings || {};
			const targetId = settings?.targetId ?? "";
			const autoAssignId = settings?.autoAssignId ?? "";
			const mode = resolveMode(settings);
			if (modeSelect) {
				modeSelect.value = mode;
			}
			if (lineSelect) {
				lineSelect.value = targetId;
			}
			if (slotSelect) {
				slotSelect.value = autoAssignId;
			}
			renderSlotOptions();
			updateVisibility();
		}

		function mergeAndSaveSettings(patch) {
			currentSettings = { ...(currentSettings || {}), ...patch };
			if (websocket && websocket.readyState === WebSocket.OPEN) {
				websocket.send(JSON.stringify({ event: "setSettings", context: uuid, payload: currentSettings }));
			}
		}

		function sendToPlugin(payload) {
			if (websocket && websocket.readyState === WebSocket.OPEN) {
				websocket.send(JSON.stringify({ event: "sendToPlugin", context: uuid, payload }));
			}
		}

		function setStatus(text) {
			if (!statusEl) return;
			statusEl.textContent = text || "";
		}

		function renderSlotOptions() {
			if (!slotSelect) return;
			const current = slotSelect.value || "";
			slotSelect.innerHTML = "";

			const prompt = document.createElement("option");
			prompt.value = "";
			prompt.textContent = "Select ID...";
			slotSelect.appendChild(prompt);

			AUTO_IDS.forEach((id) => {
				const el = document.createElement("option");
				el.value = id;
				el.textContent = `ID ${id}`;
				slotSelect.appendChild(el);
			});

			const desired = (currentSettings?.autoAssignId ?? current ?? "") || "";
			slotSelect.value = desired;
		}

		function updateVisibility() {
			const mode = resolveMode(currentSettings);
			const autoRow = document.getElementById("autoRow");
			const manualRow = document.getElementById("manualRow");
			if (autoRow) autoRow.classList.toggle("hidden", mode !== "auto");
			if (manualRow) manualRow.classList.toggle("hidden", mode !== "manual");
		}

		function buildOptions(lines) {
			return [...lines]
				.sort(lineSorter)
				.map((line) => {
					const station = stationCode(line.name);
					return {
						id: line.id,
						label: `${station} - ${friendlyName(line.name)}`,
						detail: [line.type || "Line"].filter(Boolean).join(" / "),
						station,
						type: line.type || "Line"
					};
				});
		}

		function lineSorter(a, b) {
			const priority = (line) => {
				const type = (line.type || "").toLowerCase();
				if (type.includes("hot")) return 0;
				if (type.includes("cold")) return 1;
				return 2;
			};
			const diff = priority(a) - priority(b);
			if (diff !== 0) return diff;
			return friendlyName(a.name).localeCompare(friendlyName(b.name));
		}

		function stationCode(name) {
			const tokens = wordsFromName(name).map((w) => w.toUpperCase());
			if (!tokens.length) return "";
			if (tokens.length >= 3 && ROLE_TOKENS.has(tokens[tokens.length - 1])) {
				const location = pickLocation(tokens);
				const alias = LOCATION_ALIASES[location];
				if (alias && alias.code) return alias.code;
				return location.slice(0, 3);
			}
			if (tokens.length === 2 && GROUND_TOKENS.has(tokens[1])) {
				return `${tokens[0]} SMC`;
			}
			if (tokens.length >= 3) return tokens.slice(0, 3).map((w) => (w[0] || "")).join("");
			if (tokens.length === 2) return `${tokens[0]} ${tokens[1]}`;
			return (tokens[0] || "").slice(0, 3);
		}

		function friendlyName(name) {
			const tokens = wordsFromName(name).map((w) => w.toUpperCase());
			if (!tokens.length) return "";
			if (tokens.length >= 2 && ROLE_TOKENS.has(tokens[tokens.length - 1])) {
				const location = pickLocation(tokens);
				return prettifyLocation(location, tokens[tokens.length - 1]);
			}
			if (tokens.length === 2 && GROUND_TOKENS.has(tokens[1])) {
				return `${prettifyLocation(tokens[0])} Gr`;
			}
			return tokens.map((w) => toTitle(w)).join(" ").trim();
		}

		function wordsFromName(name) {
			return (name || "")
				.replace(/[_-]+/g, " ")
				.split(/\s+/)
				.filter(Boolean);
		}

		function resolveMode(settings) {
			if (settings?.mode === "auto" || settings?.mode === "manual") return settings.mode;
			if (settings?.autoAssignId) return "auto";
			return "auto";
		}

		function pickLocation(tokens) {
			if (!tokens.length) return "";
			if (tokens.length >= 2 && ROLE_TOKENS.has(tokens[tokens.length - 1])) {
				const candidate = tokens[tokens.length - 2];
				if (candidate) return candidate;
			}
			return tokens[0] || "";
		}

		function prettifyLocation(location, role) {
			if (!location) return "";
			const alias = LOCATION_ALIASES[location];
			if (alias && alias.label) return alias.label;
			if (role && GROUND_TOKENS.has(role)) return `${toTitle(location)} Gr`;
			return toTitle(location);
		}

		function toTitle(value) {
			if (!value) return "";
			return value[0].toUpperCase() + value.slice(1).toLowerCase();
		}
	})();
	</script>
</body>
</html>
